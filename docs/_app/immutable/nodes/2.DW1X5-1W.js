import{f as E,a as v,c as ye}from"../chunks/DZzFL5Wq.js";import"../chunks/BvTvGdyi.js";import{aZ as ve,aX as be,b as we,ao as ke,k as xe,y as k,a_ as _e,$ as Ae,a0 as z,g as u,a2 as Ee,a3 as f,a5 as x,a4 as p,a6 as D,D as W,am as O,a1 as U}from"../chunks/BAKQbKSl.js";import{e as Ie,s as N}from"../chunks/D9rclCn3.js";import{i as q}from"../chunks/SV6F_dA1.js";import{t as Te,a as Ce}from"../chunks/89gb_wAD.js";import{r as Se}from"../chunks/CfPPD75W.js";import{i as Be}from"../chunks/D2lTc3ON.js";import"../chunks/B_-fIGO2.js";function Le(e,t,r=t){var s=new WeakSet;ve(e,"input",async i=>{var a=i?e.defaultValue:e.value;if(a=F(e)?j(a):a,r(a),k!==null&&s.add(k),await be(),a!==(a=t())){var o=e.selectionStart,n=e.selectionEnd,c=e.value.length;if(e.value=a??"",n!==null){var l=e.value.length;o===n&&n===c&&l>c?(e.selectionStart=l,e.selectionEnd=l):(e.selectionStart=o,e.selectionEnd=Math.min(n,l))}}}),(xe&&e.defaultValue!==e.value||we(t)==null&&e.value)&&(r(F(e)?j(e.value):e.value),k!==null&&s.add(k)),ke(()=>{var i=t();if(e===document.activeElement){var a=_e??k;if(s.has(a))return}F(e)&&i===j(e.value)||e.type==="date"&&!i&&!e.value||i!==e.value&&(e.value=i??"")})}function F(e){var t=e.type;return t==="number"||t==="range"}function j(e){return e===""?null:+e}function Oe(e){return function(...t){var r=t[0];return r.preventDefault(),e?.apply(this,t)}}const Ue=!0,Ct=Object.freeze(Object.defineProperty({__proto__:null,prerender:Ue},Symbol.toStringTag,{value:"Module"})),Ne="6.16.0";function X(e,t,r){for(let s in t){let i=t[s];Object.defineProperty(e,s,{enumerable:!0,value:i,writable:!1})}}function b(e,t){if(e==null)return"null";if(t==null&&(t=new Set),typeof e=="object"){if(t.has(e))return"[Circular]";t.add(e)}if(Array.isArray(e))return"[ "+e.map(r=>b(r,t)).join(", ")+" ]";if(e instanceof Uint8Array){const r="0123456789abcdef";let s="0x";for(let i=0;i<e.length;i++)s+=r[e[i]>>4],s+=r[e[i]&15];return s}if(typeof e=="object"&&typeof e.toJSON=="function")return b(e.toJSON(),t);switch(typeof e){case"boolean":case"number":case"symbol":return e.toString();case"bigint":return BigInt(e).toString();case"string":return JSON.stringify(e);case"object":{const r=Object.keys(e);return r.sort(),"{ "+r.map(s=>`${b(s,t)}: ${b(e[s],t)}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function qe(e,t,r){let s=e;{const a=[];if(r){if("message"in r||"code"in r||"name"in r)throw new Error(`value will overwrite populated values: ${b(r)}`);for(const o in r){if(o==="shortMessage")continue;const n=r[o];a.push(o+"="+b(n))}}a.push(`code=${t}`),a.push(`version=${Ne}`),a.length&&(e+=" ("+a.join(", ")+")")}let i;switch(t){case"INVALID_ARGUMENT":i=new TypeError(e);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":i=new RangeError(e);break;default:i=new Error(e)}return X(i,{code:t}),r&&Object.assign(i,r),i.shortMessage==null&&X(i,{shortMessage:s}),i}function Fe(e,t,r,s){if(!e)throw qe(t,r,s)}function A(e,t,r,s){Fe(e,t,"INVALID_ARGUMENT",{argument:r,value:s})}["NFD","NFC","NFKD","NFKC"].reduce((e,t)=>{try{if("test".normalize(t)!=="test")throw new Error("bad");if(t==="NFD"&&"é".normalize("NFD")!=="é")throw new Error("broken");e.push(t)}catch{}return e},[]);function je(e,t,r){if(e instanceof Uint8Array)return e;if(typeof e=="string"&&e.length%2===0&&e.match(/^0x[0-9a-f]*$/i)){const s=new Uint8Array((e.length-2)/2);let i=2;for(let a=0;a<s.length;a++)s[a]=parseInt(e.substring(i,i+2),16),i+=2;return s}A(!1,"invalid BytesLike value",t||"value",e)}function P(e,t){return je(e,t)}const K="0123456789abcdef";function Pe(e){const t=P(e);let r="0x";for(let s=0;s<t.length;s++){const i=t[s];r+=K[(i&240)>>4]+K[i&15]}return r}function G(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function se(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function J(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function He(e,t){se(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const Ve=e=>e instanceof Uint8Array,Me=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Re=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Re)throw new Error("Non little-endian hardware is not supported");function $e(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function ie(e){if(typeof e=="string"&&(e=$e(e)),!Ve(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}class ze{clone(){return this._cloneInto()}}function De(e){const t=s=>e().update(ie(s)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}const C=BigInt(2**32-1),Y=BigInt(32);function We(e,t=!1){return t?{h:Number(e&C),l:Number(e>>Y&C)}:{h:Number(e>>Y&C)|0,l:Number(e&C)|0}}function Xe(e,t=!1){let r=new Uint32Array(e.length),s=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:a,l:o}=We(e[i],t);[r[i],s[i]]=[a,o]}return[r,s]}const Ke=(e,t,r)=>e<<r|t>>>32-r,Ge=(e,t,r)=>t<<r|e>>>32-r,Je=(e,t,r)=>t<<r-32|e>>>64-r,Ye=(e,t,r)=>e<<r-32|t>>>64-r,[oe,ae,ne]=[[],[],[]],Ze=BigInt(0),_=BigInt(1),Qe=BigInt(2),et=BigInt(7),tt=BigInt(256),rt=BigInt(113);for(let e=0,t=_,r=1,s=0;e<24;e++){[r,s]=[s,(2*r+3*s)%5],oe.push(2*(5*s+r)),ae.push((e+1)*(e+2)/2%64);let i=Ze;for(let a=0;a<7;a++)t=(t<<_^(t>>et)*rt)%tt,t&Qe&&(i^=_<<(_<<BigInt(a))-_);ne.push(i)}const[st,it]=Xe(ne,!0),Z=(e,t,r)=>r>32?Je(e,t,r):Ke(e,t,r),Q=(e,t,r)=>r>32?Ye(e,t,r):Ge(e,t,r);function ot(e,t=24){const r=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let o=0;o<10;o++)r[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){const n=(o+8)%10,c=(o+2)%10,l=r[c],d=r[c+1],S=Z(l,d,1)^r[n],B=Q(l,d,1)^r[n+1];for(let h=0;h<50;h+=10)e[o+h]^=S,e[o+h+1]^=B}let i=e[2],a=e[3];for(let o=0;o<24;o++){const n=ae[o],c=Z(i,a,n),l=Q(i,a,n),d=oe[o];i=e[d],a=e[d+1],e[d]=c,e[d+1]=l}for(let o=0;o<50;o+=10){for(let n=0;n<10;n++)r[n]=e[o+n];for(let n=0;n<10;n++)e[o+n]^=~r[(n+2)%10]&r[(n+4)%10]}e[0]^=st[s],e[1]^=it[s]}r.fill(0)}class H extends ze{constructor(t,r,s,i=!1,a=24){if(super(),this.blockLen=t,this.suffix=r,this.outputLen=s,this.enableXOF=i,this.rounds=a,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,G(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Me(this.state)}keccak(){ot(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){J(this);const{blockLen:r,state:s}=this;t=ie(t);const i=t.length;for(let a=0;a<i;){const o=Math.min(r-this.pos,i-a);for(let n=0;n<o;n++)s[this.pos++]^=t[a++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:r,pos:s,blockLen:i}=this;t[s]^=r,(r&128)!==0&&s===i-1&&this.keccak(),t[i-1]^=128,this.keccak()}writeInto(t){J(this,!1),se(t),this.finish();const r=this.state,{blockLen:s}=this;for(let i=0,a=t.length;i<a;){this.posOut>=s&&this.keccak();const o=Math.min(s-this.posOut,a-i);t.set(r.subarray(this.posOut,this.posOut+o),i),this.posOut+=o,i+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return G(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(He(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:r,suffix:s,outputLen:i,rounds:a,enableXOF:o}=this;return t||(t=new H(r,s,i,o,a)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=a,t.suffix=s,t.outputLen=i,t.enableXOF=o,t.destroyed=this.destroyed,t}}const at=(e,t,r)=>De(()=>new H(t,e,r)),nt=at(1,136,256/8);let ce=!1;const le=function(e){return nt(e)};let de=le;function I(e){const t=P(e,"data");return Pe(de(t))}I._=le;I.lock=function(){ce=!0};I.register=function(e){if(ce)throw new TypeError("keccak256 is locked");de=e};Object.freeze(I);const ct=BigInt(0),lt=BigInt(36);function ee(e){e=e.toLowerCase();const t=e.substring(2).split(""),r=new Uint8Array(40);for(let i=0;i<40;i++)r[i]=t[i].charCodeAt(0);const s=P(I(r));for(let i=0;i<40;i+=2)s[i>>1]>>4>=8&&(t[i]=t[i].toUpperCase()),(s[i>>1]&15)>=8&&(t[i+1]=t[i+1].toUpperCase());return"0x"+t.join("")}const V={};for(let e=0;e<10;e++)V[String(e)]=String(e);for(let e=0;e<26;e++)V[String.fromCharCode(65+e)]=String(10+e);const te=15;function dt(e){e=e.toUpperCase(),e=e.substring(4)+e.substring(0,2)+"00";let t=e.split("").map(s=>V[s]).join("");for(;t.length>=te;){let s=t.substring(0,te);t=parseInt(s,10)%97+t.substring(s.length)}let r=String(98-parseInt(t,10)%97);for(;r.length<2;)r="0"+r;return r}const ht=(function(){const e={};for(let t=0;t<36;t++){const r="0123456789abcdefghijklmnopqrstuvwxyz"[t];e[r]=BigInt(t)}return e})();function ut(e){e=e.toLowerCase();let t=ct;for(let r=0;r<e.length;r++)t=t*lt+ht[e[r]];return t}function re(e){if(A(typeof e=="string","invalid address","address",e),e.match(/^(0x)?[0-9a-fA-F]{40}$/)){e.startsWith("0x")||(e="0x"+e);const t=ee(e);return A(!e.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||t===e,"bad address checksum","address",e),t}if(e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){A(e.substring(2,4)===dt(e),"bad icap checksum","address",e);let t=ut(e.substring(4)).toString(16);for(;t.length<40;)t="0"+t;return ee("0x"+t)}A(!1,"invalid address","address",e)}function ft(e){if(!e.startsWith("0x")||e.length!==42)return{isValid:!1,error:"Invalid address length or prefix"};const t=e.slice(2);if(!/^[a-fA-F0-9]{40}$/.test(t))return{isValid:!1,error:"Invalid hexadecimal characters"};const r="0x"+t.toLowerCase(),s=re(r);try{return re(e)===e?{isValid:!0,checksummed:e}:{isValid:!1,checksummed:s}}catch{return{isValid:!1,checksummed:s}}}var pt=E('<div class="alert alert-danger rounded-4"> </div>'),mt=E('<div class="alert alert-success rounded-4">✨ Valid Checksum!</div>'),gt=E('<div class="alert alert-warning rounded-4"><strong>Invalid Casing.</strong><br/> Corrected: <code class="d-block mt-2"> </code></div>'),yt=E('<div class="mt-4"><!> <p class="mt-2 small text-muted"><strong>Input:</strong> </p></div>'),vt=E('<section class="py-5 text-center"><div class="card border-0 shadow-lg p-4 p-md-5 mx-auto" style="max-width: 700px; border-radius: 30px;"><h1 class="mb-4 fw-bold">Ethereum Checksum Checker</h1> <p class="text-muted mb-4">Ensure your ETH transactions are safe by validating address casing.</p> <form><div class="mb-4"><input type="text" class="form-control form-control-lg text-center" id="address" placeholder="0x1234567890AbCdEf..."/></div> <button type="submit" class="btn-bubbly btn-lg w-100">Validate Checksum</button></form> <!></div></section> <hr class="my-5 opacity-10"/> <section id="about" class="py-5 container"><div class="row justify-content-center"><div class="col-lg-8"><h2 class="fw-bold text-center mb-4" style="color: var(--honey-yellow);">About This Tool</h2> <div class="prose mx-auto"><p>The Ethereum Checksum Checker is a lightweight, fully client-side web utility designed to validate Ethereum addresses according to the EIP-55 mixed-case checksum standard. Introduced in 2016, EIP-55 adds a deliberate capitalization pattern to Ethereum addresses, enabling instant detection of most typing errors without changing the underlying protocol.</p> <p>Ethereum addresses are case-insensitive at the protocol level—any mix of upper and lower case represents the same destination. This flexibility, while convenient, creates a significant risk: a single mistyped character can send funds to an entirely different address with no warning. Over the years, millions of dollars in cryptocurrency have been lost to such errors, often discovered only after irreversible transactions were confirmed.</p> <p>EIP-55 addresses this vulnerability by embedding a checksum directly into the address through selective capitalization of hexadecimal letters (a–f). The pattern is derived from a Keccak-256 hash of the lowercase address. If even one character is incorrect or the capitalization deviates from the expected pattern, the checksum fails, alerting the user immediately.</p> <p>This tool implements the official EIP-55 specification using the ethers.js library for accurate validation. All processing occurs entirely in your browser—no data is sent to servers, stored, or logged. The application is stateless and privacy-focused, making it safe for validating even sensitive addresses.</p> <p>Beyond basic validation, the tool provides helpful feedback: valid addresses receive confirmation, invalid casing is flagged with the correctly checksummed version displayed, and format errors (wrong length, invalid characters) are clearly identified. This immediate, visual response helps users correct mistakes before broadcasting transactions.</p> <p>The utility follows the original Software Requirements Specification (SRS) precisely: limited to three core pages (home validator, about, examples), exactly three functional requirements (input/validation, result display, navigation), and a single source file for all checksum logic. It is built with SvelteKit for static deployment on GitHub Pages, ensuring fast, reliable access worldwide.</p> <p>By promoting checksum awareness and providing a simple validation interface, this tool contributes to safer Ethereum interactions for developers, traders, and everyday users alike.</p></div></div></div></section> <section id="how-to-use" class="py-5 container bg-light rounded-4"><div class="row justify-content-center"><div class="col-lg-8"><h2 class="fw-bold text-center mb-4" style="color: var(--honey-yellow);">How to Use</h2> <div class="prose mx-auto"><p>Using the Ethereum Checksum Checker is straightforward and requires no account or installation. Follow these steps to validate any Ethereum address quickly and confidently.</p> <p>First, obtain the address you wish to verify. This could be a recipient address for a transfer, a contract address, or one provided by an exchange or dApp. Always copy it directly from a trusted source to minimize initial errors.</p> <p>Next, paste the address into the large input field at the top of this page. The field accepts addresses in any casing—uppercase, lowercase, or mixed. You can paste using right-click or keyboard shortcuts (Ctrl+V / Cmd+V). The tool will automatically trim whitespace.</p> <p>Click the "Validate Checksum" button or simply press Enter. Validation occurs instantly in your browser using the EIP-55 algorithm. No network requests are made, ensuring both speed and privacy.</p> <p>The result appears immediately below the form:</p> <ul><li><strong>Green success alert</strong>: The address has a valid checksum—casing matches the computed pattern perfectly. You can proceed with confidence.</li> <li><strong>Yellow warning alert</strong>: The address is structurally valid but has incorrect casing. The correctly checksummed version is displayed for easy copying.</li> <li><strong>Red danger alert</strong>: The input fails basic format checks (wrong length, missing 0x prefix, non-hexadecimal characters) or is empty.</li></ul> <p>In all cases, your original input is shown for reference. For invalid casing, copy the corrected address provided—this version includes the proper checksum while representing the same destination.</p> <p>Best practices include validating addresses at multiple stages: when copying from a source, after pasting into a wallet, and immediately before confirming a transaction. Many modern wallets perform this check automatically, but manual verification with this tool adds an extra safety layer.</p> <p>The tool works offline once loaded and is fully responsive on mobile devices. Bookmark it for quick access during transactions.</p> <p>Remember that while EIP-55 catches most common typos, it is not foolproof against sophisticated multi-character errors or cross-chain mistakes. Always double-check the first and last few characters visually, and use additional safeguards like small test transactions when sending significant amounts.</p></div></div></div></section> <section id="faq" class="py-5 container"><div class="row justify-content-center"><div class="col-lg-8"><h2 class="fw-bold text-center mb-4" style="color: var(--honey-yellow);">Frequently Asked Questions</h2> <div class="accordion accordion-flush" id="faqAccordion"><div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq1">What exactly is an EIP-55 checksum?</button></h2> <div id="faq1" class="accordion-collapse collapse" data-bs-parent="#faqAccordion"><div class="accordion-body">EIP-55 is a standard that encodes a checksum into Ethereum addresses through selective capitalization of letters a–f. The pattern is derived from a Keccak-256 hash of the lowercase address, allowing tools to detect most typing errors instantly.</div></div></div> <div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq2">Does capitalization matter in Ethereum addresses?</button></h2> <div id="faq2" class="accordion-collapse collapse" data-bs-parent="#faqAccordion"><div class="accordion-body">At the protocol level, no—Ethereum treats all casing as identical. However, correct capitalization according to EIP-55 serves as a safety check. Reputable wallets and tools enforce it to prevent errors.</div></div></div> <div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq3">Is my address sent to a server?</button></h2> <div id="faq3" class="accordion-collapse collapse" data-bs-parent="#faqAccordion"><div class="accordion-body">No. This tool is 100% client-side. All validation happens in your browser using JavaScript. Nothing is transmitted, stored, or logged.</div></div></div> <div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq4">Why does the tool show a corrected address?</button></h2> <div id="faq4" class="accordion-collapse collapse" data-bs-parent="#faqAccordion"><div class="accordion-body">If the underlying address is valid but the casing is wrong, the tool computes and displays the proper EIP-55 checksummed version for safe copying and use.</div></div></div> <div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq5">Can checksums prevent all mistakes?</button></h2> <div id="faq5" class="accordion-collapse collapse" data-bs-parent="#faqAccordion"><div class="accordion-body">No. While highly effective against single-character and most common errors, some multi-character changes can coincidentally produce valid checksums. Always verify addresses through multiple methods.</div></div></div> <div class="accordion-item"><h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq6">Do all wallets support EIP-55 validation?</button></h2> <div id="faq6" class="accordion-collapse collapse" data-bs-parent="#faqAccordion"><div class="accordion-body">Most modern wallets (MetaMask, Ledger, Trust Wallet, etc.) enforce checksum validation and display warnings for mismatches.</div></div></div></div></div></div></section>',1);function St(e,t){Ae(t,!1);let r=W(""),s=W(null);function i(){if(u(r).trim()===""){O(s,{isValid:!1,error:"Please enter an address"});return}O(s,ft(u(r)))}Be();var a=vt(),o=z(a),n=f(o),c=x(f(n),4),l=f(c),d=f(l);Se(d),p(l),D(2),p(c);var S=x(c,2);{var B=h=>{var T=yt(),M=f(T);{var he=m=>{var g=pt(),L=f(g,!0);p(g),U(()=>N(L,u(s).error)),v(m,g)},ue=m=>{var g=ye(),L=z(g);{var pe=y=>{var w=mt();v(y,w)},me=y=>{var w=gt(),$=x(f(w),3),ge=f($,!0);p($),p(w),U(()=>N(ge,u(s).checksummed)),v(y,w)};q(L,y=>{u(s).isValid?y(pe):y(me,!1)},!0)}v(m,g)};q(M,m=>{u(s).error?m(he):m(ue,!1)})}var R=x(M,2),fe=x(f(R));p(R),p(T),U(()=>N(fe,` ${u(r)??""}`)),Te(1,T,()=>Ce),v(h,T)};q(S,h=>{u(s)&&h(B)})}p(n),p(o),D(8),Le(d,()=>u(r),h=>O(r,h)),Ie("submit",c,Oe(i)),v(e,a),Ee()}export{St as component,Ct as universal};
